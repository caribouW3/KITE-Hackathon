package com.cosmo.kite.tests;

import com.cosmo.kite.exception.KiteTestException;
import com.cosmo.kite.report.custom_kite_allure.AllureStepReport;
import com.cosmo.kite.report.custom_kite_allure.AllureTestReport;
import com.cosmo.kite.report.custom_kite_allure.Reporter;
import com.cosmo.kite.report.custom_kite_allure.Status;
import com.cosmo.kite.util.TestUtils;

import javax.json.JsonObject;
import javax.json.JsonValue;
import java.io.File;
import java.util.List;

import static com.cosmo.kite.entities.Timeouts.ONE_SECOND_INTERVAL;
import static com.cosmo.kite.entities.Timeouts.TEN_SECOND_INTERVAL;
import static com.cosmo.kite.util.ReportUtils.getStackTrace;
import static com.cosmo.kite.util.TestUtils.readJsonFile;
import static com.cosmo.kite.util.TestUtils.waitAround;

public class KiteJsCallable extends  KiteCallable {
  // todo set WORKING_DIR
  private final String WORKING_DIR = "js/";
  private final String jsTestImpl;
  private final int id;
  private int numberOfParticipant;
  private String reportPath;
  
  public KiteJsCallable(AllureTestReport testReport, String jsTestImpl, int id) {
    super(null, testReport);
    this.jsTestImpl = jsTestImpl;
    this.id = id;
  }
  
  public void setNumberOfParticipant(int numberOfParticipant) {
    this.numberOfParticipant = numberOfParticipant;
  }
  
  public void setReportPath(String reportPath) {
    this.reportPath = "./" + reportPath;
  }
  
  @Override
  public Object call() {
    // todo: run the js test with a unique id (self-generated)
    // todo: test completion check (by file existence maybe)
    // todo: retrieve result from file and create allure report
    // todo: NOTE: result from JS does not need to be in Allure report format (yet)
    String resultPath = WORKING_DIR + this.reportPath + "/" + id + "/result.json";
    try {
      List<String> command = java.util.Arrays.asList("node", jsTestImpl, "" + numberOfParticipant, "" + id,  reportPath);
      TestUtils.executeCommand(WORKING_DIR, command, logger, jsTestImpl + "_" + id);
      waitForResultFile(resultPath);
      //processResult(readJsonFile(resultPath));
    } catch (Exception e) {
      logger.error(getStackTrace(e));
    }
    return null;
  }
  
  private void waitForResultFile(String filePath) throws KiteTestException {
    for (int wait = 0; wait < TEN_SECOND_INTERVAL; wait += ONE_SECOND_INTERVAL) {
      File resultFile = new File(filePath);
      if (resultFile.exists()) {
        logger.info("Found result file at:" + filePath);
        return;
      }
      waitAround(ONE_SECOND_INTERVAL);
    }
    throw new KiteTestException("Could not find result file generated by Js", Status.FAILED);
  }
  
  private AllureStepReport processResult(JsonObject result) throws KiteTestException {
    if (result != null) {
      AllureStepReport stepReport = new AllureStepReport(result.getString("name", "place holder"));
      stepReport.setStatus(Status.PASSED);
      stepReport.setStartTimestamp((long) result.getInt("start"));
      stepReport.setStopTimestamp((long) result.getInt("stop"));
      if (result.get("attachment") != null) {
        JsonObject attachmentObj = result.getJsonObject("attachment");
        String type =attachmentObj.getString("type", "plain");
        if (!type.equals("png"))
        Reporter.getInstance().textAttachment(stepReport, "attachment", attachmentObj.getJsonObject("value").toString(), type);
      }
      if (result.get("steps") != null) {
        for (JsonValue value : result.getJsonArray("steps")) {
          JsonObject stepObject = (JsonObject) value;
          stepReport.addStepReport(processResult(stepObject));
        }
      }
      return stepReport;
    }
    throw new KiteTestException("There's a null value in the report", Status.BROKEN);
  }
}
